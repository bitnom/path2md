**.gitignore**
```
.python-version
.venv
**/**/__pycache__

```

**.python-version**
```
3.11

```

**poetry.lock**
```lock
# This file is automatically @generated by Poetry 1.8.3 and should not be changed by hand.

[[package]]
name = "gitignore-parser"
version = "0.1.11"
description = "A spec-compliant gitignore parser for Python 3.5+"
optional = false
python-versions = "*"
files = [
    {file = "gitignore_parser-0.1.11.tar.gz", hash = "sha256:fa10fde48b44888eeefac096f53bcdad9b87a4ffd7db788558dbdf71ff3bc9db"},
]

[metadata]
lock-version = "2.0"
python-versions = ">=3.11,<=3.12"
content-hash = "4e71c1bd630303a26789869379aaedd484638c0be860945c9e97c5578f66a730"

```

**pyproject.toml**
```toml
[project]
name = "path2md"
version = "0.4.0"
description = "Input file or dir path, output markdown file(s)."
authors = [
  { name = "bitnom", email = "14287229+bitnom@users.noreply.github.com" }
]
license = "Apache-2.0"
readme = "README.md"
requires-python = ">=3.11,<=3.12"
dependencies = [
    "gitignore-parser>=0.1.11",
]

[project.scripts]
path2md = "path2md.cli:main"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.poetry]
name = "path2md"
version = "0.3.3"
description = "Input file or dir path, output markdown file(s)."
authors = ["bitnom <14287229+bitnom@users.noreply.github.com>"]
license = "Apache-2.0"
readme = "README.md"

[tool.poetry.dependencies]
python = ">=3.11,<=3.12"
gitignore-parser = "^0.1.11"

[tool.poetry.scripts]
path2md = "path2md.cli:main"

```

**README.md**
```md
# path2md

**Version**: 0.4.0  
**Author**: [bitnom](https://github.com/bitnom)  
**License**: Apache License 2.0  

## Table of Contents

- [Overview](#overview)
- [Installation](#installation)
  - [Install via uv (Recommended)](#install-via-uv-recommended)
  - [Install via pip](#install-via-pip)
  - [Install via Poetry](#install-via-poetry)
- [Usage](#usage)
  - [Basic Example](#basic-example)
  - [Specifying File Extensions](#specifying-file-extensions)
  - [Omitting Files or Directories](#omitting-files-or-directories)
  - [Truncating Lines or Strings](#truncating-lines-or-strings)
  - [Removing Comments](#removing-comments)
  - [Limiting Recursion Depth](#limiting-recursion-depth)
  - [Whitelisting Files or Directories](#whitelisting-files-or-directories)
  - [Using Gitignore](#using-gitignore)
  - [Output Options](#output-options)
  - [File Size Limit and Binary Files](#file-size-limit-and-binary-files)
- [How It Works](#how-it-works)
- [Known Limitations and Caveats](#known-limitations-and-caveats)
- [Contributing](#contributing)
- [License](#license)

---

## Overview

`path2md` is a command-line tool designed to collect files from a given directory (and its subdirectories) and wrap each file’s content in Markdown code fences. This lets you quickly generate documentation or share your code snippets in a Markdown-friendly format. You can:

- Restrict which files to include (by file extension, whitelists, or `.gitignore`).  
- **Parse all file extensions by default** (unless you explicitly provide `--extensions`).  
- Omit files by extension or filename but still note their presence in the output.  
- Optionally strip comments to reduce clutter.  
- Truncate lines and/or strings to limit overly long content.  
- Limit consecutive empty lines to make the output more compact.  
- **Skip files larger than a specified maximum size** (`--max-size`, default 100 KB).  
- **Always skip binary files** automatically.  
- Produce either a single Markdown file or multiple Markdown files (one per source file).

This tool is especially helpful if you want to share or document multiple files (e.g., sample code, config files) without manually copying and pasting them into code blocks.

---

## Installation

### Install via uv (Recommended)

If you haven’t used **uv** before, it’s a lightweight Python project management tool that helps isolate dependencies. You can install **uv** system-wide with:

```bash
pip install uv
```

Then follow these steps:

1. **Clone** or **download** this repository.
2. In the project directory (where your `pyproject.toml` is located), run:

   ```bash
   uv install
   ```

3. Once installed, you can run:

   ```bash
   uv run path2md --help
   ```

   Or simply:

   ```bash
   uv path2md --help
   ```

   depending on your uv version/configuration.

### Install via pip

1. **Clone** or **download** this repository.
2. From the top-level directory (with the `pyproject.toml`), run:

   ```bash
   pip install .
   ```

   This will build and install the package into your current Python environment.
3. Once installed, you can run:

   ```bash
   path2md --help
   ```

> **Note:** If you want to install in “editable”/dev mode, use:
> ```bash
> pip install -e .
> ```
> Then any local changes to the code reflect immediately.

### Install via Poetry

1. **Clone** or **download** this repository.
2. In the project directory, run:

   ```bash
   poetry install
   ```

3. Once installed, you can:
   - Use it directly via:
     ```bash
     poetry run path2md --help
     ```
   - Or activate the virtual environment (`poetry shell`) and then run:
     ```bash
     path2md --help
     ```

---

## Usage

After installation (via uv, pip, or Poetry), you’ll have a `path2md` CLI command in your PATH. Run:

```bash
path2md <directory> [options]
```

Below is a summary of all the available options:

```txt
positional arguments:
  directory             Directory containing files to process.

optional arguments:
  --output-file OUTPUT_FILE
                        Output markdown file path.
  --output-dir OUTPUT_DIR
                        Output directory for individual markdown files.
  --extensions EXTENSIONS
                        Comma-separated list of file extensions to process.
                        If not provided, ALL file extensions are processed
                        (excluding binary files).
  --omit OMIT
                        Comma-separated list of file extensions to omit
                        (source omitted but file is noted).
  --omit-files OMIT_FILES
                        Comma-separated list of filenames to omit (source
                        omitted but file is noted).
  --omit-dirs OMIT_DIRS
                        Comma-separated list of directory names to omit
                        from traversal entirely.
  --truncln TRUNCLN
                        Truncate lines longer than this many characters.
  --truncstr TRUNCSTR
                        Truncate strings longer than this many characters.
  --nocom
                        Omit all line/block comments from the output.
  --maxlnspace MAXLNSPACE
                        Maximum number of consecutive empty lines allowed.
  --depth DEPTH
                        Limit directory recursion depth.
  --whitelist-files WHITELIST_FILES
                        Comma-separated list of files to parse.
  --whitelist-dirs WHITELIST_DIRS
                        Comma-separated list of directory names to traverse.
  --whitelist WHITELIST
                        Comma-separated list of files/dirs to process.
  --gitignore GITIGNORE
                        Path to a .gitignore file (global).
  --obey-gitignores
                        Obey .gitignore files found in traversed directories.
  --max-size MAX_SIZE
                        Maximum file size in bytes to process (default: 100 KB).
  --version
                        Show program's version number and exit.
```

### Basic Example

```bash
path2md my_project --output-file project_snippets.md
```

- Traverses `my_project/` looking for **all file extensions** by default (skipping binary files and those over 100 KB).  
- Outputs all discovered (non-binary) files into a single Markdown file named `project_snippets.md`.

### Specifying File Extensions

To only include certain extensions:

```bash
path2md my_project --extensions py,js,json
```

This processes **only** `.py`, `.js`, and `.json` files (still skipping binary files and those over 100 KB).

### Omitting Files or Directories

You can omit files by extension or by exact filename:

```bash
# Omit .env and .lock files, but still note them in the output
path2md my_project --omit env,lock
```

To **completely skip** a directory, use `--omit-dirs`:

```bash
path2md my_project --omit-dirs node_modules,build
```

Any directory named `node_modules` or `build` will not be entered during traversal.

### Truncating Lines or Strings

- `--truncln` truncates individual lines if they exceed a certain length.
- `--truncstr` truncates string literals (e.g., `"..."`, `'...'`, triple quotes, backticks).

Example:

```bash
path2md my_project --truncln 120 --truncstr 200
```

Lines over 120 characters will be shortened, and string literals over 200 characters will be truncated.

### Removing Comments

Use `--nocom` to strip out comments:

```bash
path2md my_project --nocom
```

Currently, this removes:
- `# ...` lines in Python.
- `// ...` lines and `/* ... */` blocks in JS/TS/CSS/HTML.

It is a naive removal (simple regex-based) and won’t handle advanced edge cases (like `#` in a string).

### Limiting Recursion Depth

If you only want to scan subdirectories up to a certain depth from the initial directory:

```bash
path2md my_project --depth 2
```

- `depth=0` means only the directory itself.  
- `depth=1` means the directory and its immediate subdirectories.  

### Whitelisting Files or Directories

If you only want to process specific files or directories:

```bash
path2md my_project --whitelist-files main.py,settings.py
```

This will only process `main.py` and `settings.py` (within the given directory). Similarly, `--whitelist-dirs` only traverses directories whose names match the whitelist. The more general `--whitelist` applies to both file and directory names.

### Using Gitignore

You can specify a global `.gitignore` to skip certain files:

```bash
path2md my_project --gitignore /path/to/.gitignore
```

Or, if you want the script to obey any `.gitignore` found inside subdirectories:

```bash
path2md my_project --obey-gitignores
```

This means each subdirectory’s `.gitignore` rules are also applied.

### Output Options

1. **Output to a single Markdown file**:

   ```bash
   path2md my_project --output-file output.md
   ```

2. **Output to multiple Markdown files (one per source file)**:

   ```bash
   path2md my_project --output-dir output_folder
   ```

   This creates `output_folder/` if it doesn’t exist, then places individual `.md` files for each source file. The filenames are based on the relative paths of the source files but sanitized for filesystem safety.

3. **Output to STDOUT** (default if neither `--output-file` nor `--output-dir` is specified):

   ```bash
   path2md my_project
   ```

### File Size Limit and Binary Files

- By default, files larger than **100 KB** are skipped. You can customize this limit with `--max-size <BYTES>`.
- The script **always skips binary files**. Any file containing a null byte (`\0`) in the first 1024 bytes is treated as binary, and it won’t be included in the output.

---

## How It Works

1. **Argument Parsing**  
   The script reads all CLI options and determines which files/directories to traverse or skip.

2. **File Collection**  
   - Uses `os.walk()` to scan the specified directory.  
   - Checks optional recursion depth, directory whitelists/omits, `.gitignore` rules, and maximum file size to filter out unwanted paths.  
   - Automatically **skips binary files**.  
   - By default, if `--extensions` is **not** provided, **all** non-binary files under the `max-size` limit are processed.

3. **Fencing Content**  
   For each file that passes the filters:
   - If its extension or filename is in the “omit” lists, it’s only *referenced* (with a note that content is omitted).  
   - Otherwise, the script reads the file content, optionally removes comments, truncates lines/strings, and limits consecutive empty lines.  
   - Wraps the processed text in Markdown fences.

4. **Output**  
   - All fenced content is joined into a single string or separated into multiple Markdown files as requested.  
   - If splitting into multiple files, the script uses a simple split logic on the combined string and writes each chunk to an individual `.md` file.

---

## Known Limitations and Caveats

1. **Naive Regex for Comments and Strings**  
   - The regex approach may remove content that merely *resembles* a comment (e.g., `//` in a string).  
   - Similarly, string truncation might behave unexpectedly with nested quotes or escaped characters.

2. **Splitting Output in `--output-dir` Mode**  
   - The script splits combined content on `\n**`, which might conflict if your files legitimately contain that exact sequence in code. This is unlikely but worth noting.  

3. **Overwriting Files**  
   - If two different source files sanitize to the same name, the second will overwrite the first in the output directory. (For example, `foo/bar.py` and `foo:bar.py` both becoming `foo_bar_py.md`.)

4. **Case Sensitivity**  
   - On some filesystems (e.g., Windows), filename case might cause collisions in `--output-dir` mode.

If these caveats don’t affect your typical use, the script should work fine.

---

## Contributing

Contributions, bug reports, and feature requests are welcome. Please open an issue or submit a pull request on the [GitHub repository](https://github.com/bitnom/path2md) (or wherever the project is hosted).

When submitting code changes, please ensure you:

1. Write clear commit messages.  
2. Include testing or sample usage if you introduce new features.  
3. Adhere to Pythonic style (PEP 8).

---

## License

This project is under the [Apache License 2.0](https://www.apache.org/licenses/LICENSE-2.0). Feel free to modify or distribute under the terms of that license, or use a different license if you prefer.
```

**uv.lock**
```lock
version = 1
requires-python = ">=3.11, <=3.12"

[[package]]
name = "gitignore-parser"
version = "0.1.11"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/19/59/b4fc550b7b07e8951eefbc3208162f509f5d6a381602b66a20a6288b8275/gitignore_parser-0.1.11.tar.gz", hash = "sha256:fa10fde48b44888eeefac096f53bcdad9b87a4ffd7db788558dbdf71ff3bc9db", size = 5284 }

[[package]]
name = "path2md"
version = "0.4.0"
source = { editable = "." }
dependencies = [
    { name = "gitignore-parser" },
]

[package.metadata]
requires-dist = [{ name = "gitignore-parser", specifier = ">=0.1.11" }]

```

**.git\COMMIT_EDITMSG**
```
better install instructions

```

**.git\config**
```
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[remote "origin"]
	url = https://github.com/bitnom/path2md.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
	remote = origin
	merge = refs/heads/master

```

**.git\description**
```
Unnamed repository; edit this file 'description' to name the repository.

```

**.git\HEAD**
```
ref: refs/heads/master

```

**.git\hooks\applypatch-msg.sample**
```sample
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:

```

**.git\hooks\commit-msg.sample**
```sample
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}

```

**.git\hooks\fsmonitor-watchman.sample**
```sample
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}

```

**.git\hooks\post-update.sample**
```sample
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info

```

**.git\hooks\pre-applypatch.sample**
```sample
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:

```

**.git\hooks\pre-commit.sample**
```sample
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --

```

**.git\hooks\pre-merge-commit.sample**
```sample
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:

```

**.git\hooks\pre-push.sample**
```sample
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0

```

**.git\hooks\pre-rebase.sample**
```sample
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END

```

**.git\hooks\pre-receive.sample**
```sample
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi

```

**.git\hooks\prepare-commit-msg.sample**
```sample
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi

```

**.git\hooks\push-to-checkout.sample**
```sample
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi

```

**.git\hooks\sendemail-validate.sample**
```sample
#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi

```

**.git\hooks\update.sample**
```sample
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0

```

**.git\info\exclude**
```
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~

```

**.git\logs\HEAD**
```
0000000000000000000000000000000000000000 48b6750b32470408fa99b03b6a93176fffba1d11 bitnom <14287229+bitnom@users.noreply.github.com> 1721198921 -0400	commit (initial): init
48b6750b32470408fa99b03b6a93176fffba1d11 2540fc35634526e166bc5554d802e00e3b84d348 bitnom <14287229+bitnom@users.noreply.github.com> 1736461168 -0500	commit: feat: --output-dir
2540fc35634526e166bc5554d802e00e3b84d348 baa776381bc3356c3a92019e1d850ff68a1eb2ad bitnom <14287229+bitnom@users.noreply.github.com> 1736461263 -0500	commit: feat(path2md.py): add output directory support and version flag
baa776381bc3356c3a92019e1d850ff68a1eb2ad b9c509d87f8f6725917b8faaed9c7d0f2a311cf1 bitnom <14287229+bitnom@users.noreply.github.com> 1736461563 -0500	commit (amend): feat(path2md.py): add output directory support and version flag
b9c509d87f8f6725917b8faaed9c7d0f2a311cf1 eaecbdaf75231b242f4708f6260e0fe11571a6e3 bitnom <14287229+bitnom@users.noreply.github.com> 1736461768 -0500	commit: update readme and license
eaecbdaf75231b242f4708f6260e0fe11571a6e3 d31316abb11e22b23d74b114a27f5ed635af3eba bitnom <14287229+bitnom@users.noreply.github.com> 1736461921 -0500	commit: fix: author
d31316abb11e22b23d74b114a27f5ed635af3eba 89983f6635b0aa7513d05ff1e4d5de2b85920ecd bitnom <14287229+bitnom@users.noreply.github.com> 1736463146 -0500	commit: feat: as cli tool
89983f6635b0aa7513d05ff1e4d5de2b85920ecd 82aab891b58eec2b1c8e90e8281ee2762de80ec3 bitnom <14287229+bitnom@users.noreply.github.com> 1736463272 -0500	commit: fix: github url
82aab891b58eec2b1c8e90e8281ee2762de80ec3 e322094f12924443c99ac2c1206709b77f7e3bdc bitnom <14287229+bitnom@users.noreply.github.com> 1736463545 -0500	commit: add cli info to readme
e322094f12924443c99ac2c1206709b77f7e3bdc ed1ca68d67c04a9541ca6718e1e7264f5bca1b19 bitnom <14287229+bitnom@users.noreply.github.com> 1736464397 -0500	commit: feat: support uv
ed1ca68d67c04a9541ca6718e1e7264f5bca1b19 53a4397506f721f8dc3be0f6e0353d1c72484d99 bitnom <14287229+bitnom@users.noreply.github.com> 1736464640 -0500	commit: fix: gitignore
53a4397506f721f8dc3be0f6e0353d1c72484d99 87719716b6d5c64210cb6575097936548d428865 bitnom <14287229+bitnom@users.noreply.github.com> 1736465693 -0500	commit: feat: 0.4.0
87719716b6d5c64210cb6575097936548d428865 ccdbd0aa997775fcb8af701b7a32fee45767cf3d bitnom <14287229+bitnom@users.noreply.github.com> 1736466098 -0500	commit: better install instructions

```

**.git\logs\refs\heads\master**
```
0000000000000000000000000000000000000000 48b6750b32470408fa99b03b6a93176fffba1d11 bitnom <14287229+bitnom@users.noreply.github.com> 1721198921 -0400	commit (initial): init
48b6750b32470408fa99b03b6a93176fffba1d11 2540fc35634526e166bc5554d802e00e3b84d348 bitnom <14287229+bitnom@users.noreply.github.com> 1736461168 -0500	commit: feat: --output-dir
2540fc35634526e166bc5554d802e00e3b84d348 baa776381bc3356c3a92019e1d850ff68a1eb2ad bitnom <14287229+bitnom@users.noreply.github.com> 1736461263 -0500	commit: feat(path2md.py): add output directory support and version flag
baa776381bc3356c3a92019e1d850ff68a1eb2ad b9c509d87f8f6725917b8faaed9c7d0f2a311cf1 bitnom <14287229+bitnom@users.noreply.github.com> 1736461563 -0500	commit (amend): feat(path2md.py): add output directory support and version flag
b9c509d87f8f6725917b8faaed9c7d0f2a311cf1 eaecbdaf75231b242f4708f6260e0fe11571a6e3 bitnom <14287229+bitnom@users.noreply.github.com> 1736461768 -0500	commit: update readme and license
eaecbdaf75231b242f4708f6260e0fe11571a6e3 d31316abb11e22b23d74b114a27f5ed635af3eba bitnom <14287229+bitnom@users.noreply.github.com> 1736461921 -0500	commit: fix: author
d31316abb11e22b23d74b114a27f5ed635af3eba 89983f6635b0aa7513d05ff1e4d5de2b85920ecd bitnom <14287229+bitnom@users.noreply.github.com> 1736463146 -0500	commit: feat: as cli tool
89983f6635b0aa7513d05ff1e4d5de2b85920ecd 82aab891b58eec2b1c8e90e8281ee2762de80ec3 bitnom <14287229+bitnom@users.noreply.github.com> 1736463272 -0500	commit: fix: github url
82aab891b58eec2b1c8e90e8281ee2762de80ec3 e322094f12924443c99ac2c1206709b77f7e3bdc bitnom <14287229+bitnom@users.noreply.github.com> 1736463545 -0500	commit: add cli info to readme
e322094f12924443c99ac2c1206709b77f7e3bdc ed1ca68d67c04a9541ca6718e1e7264f5bca1b19 bitnom <14287229+bitnom@users.noreply.github.com> 1736464397 -0500	commit: feat: support uv
ed1ca68d67c04a9541ca6718e1e7264f5bca1b19 53a4397506f721f8dc3be0f6e0353d1c72484d99 bitnom <14287229+bitnom@users.noreply.github.com> 1736464640 -0500	commit: fix: gitignore
53a4397506f721f8dc3be0f6e0353d1c72484d99 87719716b6d5c64210cb6575097936548d428865 bitnom <14287229+bitnom@users.noreply.github.com> 1736465693 -0500	commit: feat: 0.4.0
87719716b6d5c64210cb6575097936548d428865 ccdbd0aa997775fcb8af701b7a32fee45767cf3d bitnom <14287229+bitnom@users.noreply.github.com> 1736466098 -0500	commit: better install instructions

```

**.git\logs\refs\remotes\origin\master**
```
0000000000000000000000000000000000000000 eaecbdaf75231b242f4708f6260e0fe11571a6e3 bitnom <14287229+bitnom@users.noreply.github.com> 1736461869 -0500	update by push
eaecbdaf75231b242f4708f6260e0fe11571a6e3 d31316abb11e22b23d74b114a27f5ed635af3eba bitnom <14287229+bitnom@users.noreply.github.com> 1736461928 -0500	update by push
d31316abb11e22b23d74b114a27f5ed635af3eba 89983f6635b0aa7513d05ff1e4d5de2b85920ecd bitnom <14287229+bitnom@users.noreply.github.com> 1736463159 -0500	update by push
89983f6635b0aa7513d05ff1e4d5de2b85920ecd e322094f12924443c99ac2c1206709b77f7e3bdc bitnom <14287229+bitnom@users.noreply.github.com> 1736463578 -0500	update by push
e322094f12924443c99ac2c1206709b77f7e3bdc ed1ca68d67c04a9541ca6718e1e7264f5bca1b19 bitnom <14287229+bitnom@users.noreply.github.com> 1736464406 -0500	update by push
ed1ca68d67c04a9541ca6718e1e7264f5bca1b19 53a4397506f721f8dc3be0f6e0353d1c72484d99 bitnom <14287229+bitnom@users.noreply.github.com> 1736464647 -0500	update by push
53a4397506f721f8dc3be0f6e0353d1c72484d99 87719716b6d5c64210cb6575097936548d428865 bitnom <14287229+bitnom@users.noreply.github.com> 1736465701 -0500	update by push
87719716b6d5c64210cb6575097936548d428865 ccdbd0aa997775fcb8af701b7a32fee45767cf3d bitnom <14287229+bitnom@users.noreply.github.com> 1736466104 -0500	update by push

```

**.git\objects\0f\c687e45cab188c49c26b46c65a8f4a0b509997** (Error reading file: 'utf-8' codec can't decode byte 0x8e in position 5: invalid start byte)

**.git\objects\53\a4397506f721f8dc3be0f6e0353d1c72484d99** (Error reading file: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte)

**.git\objects\6a\a8d75dd838532549514c0246c2b3c5d250c41c** (Error reading file: 'utf-8' codec can't decode byte 0xbd in position 2: invalid start byte)

**.git\objects\7e\5c07abb7a2b0f8dac9a642d08ba2895430183c** (Error reading file: 'utf-8' codec can't decode byte 0xdb in position 6: invalid continuation byte)

**.git\objects\82\aab891b58eec2b1c8e90e8281ee2762de80ec3** (Error reading file: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte)

**.git\objects\87\719716b6d5c64210cb6575097936548d428865** (Error reading file: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte)

**.git\objects\89\983f6635b0aa7513d05ff1e4d5de2b85920ecd** (Error reading file: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte)

**.git\objects\8f\32b2f2fe9fa93ece93092b19b52d89f29eb9b7** (Error reading file: 'utf-8' codec can't decode byte 0x90 in position 3: invalid start byte)

**.git\objects\c1\be0394738fd9dedc818b9ec89b2488cae2815d** (Error reading file: 'utf-8' codec can't decode byte 0xdb in position 6: invalid continuation byte)

**.git\objects\d3\1316abb11e22b23d74b114a27f5ed635af3eba** (Error reading file: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte)

**.git\objects\e5\08a4b9e8333a1949d940b6d14dd72e3e098f46** (Error reading file: 'utf-8' codec can't decode byte 0x9d in position 2: invalid start byte)

**.git\objects\ea\ecbdaf75231b242f4708f6260e0fe11571a6e3** (Error reading file: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte)

**.git\objects\ed\1ca68d67c04a9541ca6718e1e7264f5bca1b19** (Error reading file: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte)

**.git\objects\f2\7f8c174f80c0684bbe839ea5475dda7b18c0c9** (Error reading file: 'utf-8' codec can't decode byte 0xbd in position 2: invalid start byte)

**.git\refs\heads\master**
```
ccdbd0aa997775fcb8af701b7a32fee45767cf3d

```

**.git\refs\remotes\origin\master**
```
ccdbd0aa997775fcb8af701b7a32fee45767cf3d

```

**.venv\.gitignore**
```
*
```

**.venv\CACHEDIR.TAG**
```TAG
Signature: 8a477f597d28d172789f06886806bc55
```

**.venv\pyvenv.cfg**
```cfg
home = C:\Users\bitnom\.pyenv\pyenv-win\versions\3.11.9
implementation = CPython
uv = 0.5.5
version_info = 3.11.9
include-system-site-packages = false
prompt = path2md

```

**.venv\Lib\site-packages\gitignore_parser.py**
```py
import collections
import os
import re

from os.path import abspath, dirname
from pathlib import Path
from typing import Reversible, Union

def handle_negation(file_path, rules: Reversible["IgnoreRule"]):
    for rule in reversed(rules):
        if rule.match(file_path):
            return not rule.negation
    return False

def parse_gitignore(full_path, base_dir=None):
    if base_dir is None:
        base_dir = dirname(full_path)
    rules = []
    with open(full_path) as ignore_file:
        counter = 0
        for line in ignore_file:
            counter += 1
            line = line.rstrip('\n')
            rule = rule_from_pattern(line, base_path=_normalize_path(base_dir),
                                     source=(full_path, counter))
            if rule:
                rules.append(rule)
    if not any(r.negation for r in rules):
        return lambda file_path: any(r.match(file_path) for r in rules)
    else:
        # We have negation rules. We can't use a simple "any" to evaluate them.
        # Later rules override earlier rules.
        return lambda file_path: handle_negation(file_path, rules)

def rule_from_pattern(pattern, base_path=None, source=None):
    """
    Take a .gitignore match pattern, such as "*.py[cod]" or "**/*.bak",
    and return an IgnoreRule suitable for matching against files and
    directories. Patterns which do not match files, such as comments
    and blank lines, will return None.
    Because git allows for nested .gitignore files, a base_path value
    is required for correct behavior. The base path should be absolute.
    """
    # Store the exact pattern for our repr and string functions
    orig_pattern = pattern
    # Early returns follow
    # Discard comments and separators
    if pattern.strip() == '' or pattern[0] == '#':
        return
    # Strip leading bang before examining double asterisks
    if pattern[0] == '!':
        negation = True
        pattern = pattern[1:]
    else:
        negation = False
    # Multi-asterisks not surrounded by slashes (or at the start/end) should
    # be treated like single-asterisks.
    pattern = re.sub(r'([^/])\*{2,}', r'\1*', pattern)
    pattern = re.sub(r'\*{2,}([^/])', r'*\1', pattern)

    # Special-casing '/', which doesn't match any files or directories
    if pattern.rstrip() == '/':
        return

    directory_only = pattern[-1] == '/'
    # A slash is a sign that we're tied to the base_path of our rule
    # set.
    anchored = '/' in pattern[:-1]
    if pattern[0] == '/':
        pattern = pattern[1:]
    if pattern[0] == '*' and len(pattern) >= 2 and pattern[1] == '*':
        pattern = pattern[2:]
        anchored = False
    if pattern[0] == '/':
        pattern = pattern[1:]
    if pattern[-1] == '/':
        pattern = pattern[:-1]
    # patterns with leading hashes or exclamation marks are escaped with a
    # backslash in front, unescape it
    if pattern[0] == '\\' and pattern[1] in ('#', '!'):
        pattern = pattern[1:]
    # trailing spaces are ignored unless they are escaped with a backslash
    i = len(pattern)-1
    striptrailingspaces = True
    while i > 1 and pattern[i] == ' ':
        if pattern[i-1] == '\\':
            pattern = pattern[:i-1] + pattern[i:]
            i = i - 1
            striptrailingspaces = False
        else:
            if striptrailingspaces:
                pattern = pattern[:i]
        i = i - 1
    regex = fnmatch_pathname_to_regex(
        pattern, directory_only, negation, anchored=bool(anchored)
    )
    return IgnoreRule(
        pattern=orig_pattern,
        regex=regex,
        negation=negation,
        directory_only=directory_only,
        anchored=anchored,
        base_path=_normalize_path(base_path) if base_path else None,
        source=source
    )


IGNORE_RULE_FIELDS = [
    'pattern', 'regex',  # Basic values
    'negation', 'directory_only', 'anchored',  # Behavior flags
    'base_path',  # Meaningful for gitignore-style behavior
    'source'  # (file, line) tuple for reporting
]


class IgnoreRule(collections.namedtuple('IgnoreRule_', IGNORE_RULE_FIELDS)):
    def __str__(self):
        return self.pattern

    def __repr__(self):
        return ''.join(['IgnoreRule(\'', self.pattern, '\')'])

    def match(self, abs_path: Union[str, Path]):
        matched = False
        if self.base_path:
            rel_path = str(_normalize_path(abs_path).relative_to(self.base_path))
        else:
            rel_path = str(_normalize_path(abs_path))
        # Path() strips the trailing slash, so we need to preserve it
        # in case of directory-only negation
        if self.negation and type(abs_path) == str and abs_path[-1] == '/':
            rel_path += '/'
        if rel_path.startswith('./'):
            rel_path = rel_path[2:]
        if re.search(self.regex, rel_path):
            matched = True
        return matched


# Frustratingly, python's fnmatch doesn't provide the FNM_PATHNAME
# option that .gitignore's behavior depends on.
def fnmatch_pathname_to_regex(
    pattern, directory_only: bool, negation: bool, anchored: bool = False
):
    """
    Implements fnmatch style-behavior, as though with FNM_PATHNAME flagged;
    the path separator will not match shell-style '*' and '.' wildcards.
    """
    i, n = 0, len(pattern)

    seps = [re.escape(os.sep)]
    if os.altsep is not None:
        seps.append(re.escape(os.altsep))
    seps_group = '[' + '|'.join(seps) + ']'
    nonsep = r'[^{}]'.format('|'.join(seps))

    res = []
    while i < n:
        c = pattern[i]
        i += 1
        if c == '*':
            try:
                if pattern[i] == '*':
                    i += 1
                    if i < n and pattern[i] == '/':
                        i += 1
                        res.append(''.join(['(.*', seps_group, ')?']))
                    else:
                        res.append('.*')
                else:
                    res.append(''.join([nonsep, '*']))
            except IndexError:
                res.append(''.join([nonsep, '*']))
        elif c == '?':
            res.append(nonsep)
        elif c == '/':
            res.append(seps_group)
        elif c == '[':
            j = i
            if j < n and pattern[j] == '!':
                j += 1
            if j < n and pattern[j] == ']':
                j += 1
            while j < n and pattern[j] != ']':
                j += 1
            if j >= n:
                res.append('\\[')
            else:
                stuff = pattern[i:j].replace('\\', '\\\\').replace('/', '')
                i = j + 1
                if stuff[0] == '!':
                    stuff = ''.join(['^', stuff[1:]])
                elif stuff[0] == '^':
                    stuff = ''.join('\\' + stuff)
                res.append('[{}]'.format(stuff))
        else:
            res.append(re.escape(c))
    if anchored:
        res.insert(0, '^')
    else:
        res.insert(0, f"(^|{seps_group})")
    if not directory_only:
        res.append('$')
    elif directory_only and negation:
        res.append('/$')
    else:
        res.append('($|\\/)')
    return ''.join(res)


def _normalize_path(path: Union[str, Path]) -> Path:
    """Normalize a path without resolving symlinks.

    This is equivalent to `Path.resolve()` except that it does not resolve symlinks.
    Note that this simplifies paths by removing double slashes, `..`, `.` etc. like
    `Path.resolve()` does.
    """
    return Path(abspath(path))

```

**.venv\Lib\site-packages\path2md.pth**
```pth
E:/Users/bitnom/Code/path2md

```

**.venv\Lib\site-packages\_virtualenv.pth**
```pth
import _virtualenv
```

**.venv\Lib\site-packages\_virtualenv.py**
```py
"""Patches that are applied at runtime to the virtual environment."""

import os
import sys

VIRTUALENV_PATCH_FILE = os.path.join(__file__)


def patch_dist(dist):
    """
    Distutils allows user to configure some arguments via a configuration file:
    https://docs.python.org/3.11/install/index.html#distutils-configuration-files.

    Some of this arguments though don't make sense in context of the virtual environment files, let's fix them up.
    """  # noqa: D205
    # we cannot allow some install config as that would get packages installed outside of the virtual environment
    old_parse_config_files = dist.Distribution.parse_config_files

    def parse_config_files(self, *args, **kwargs):
        result = old_parse_config_files(self, *args, **kwargs)
        install = self.get_option_dict("install")

        if "prefix" in install:  # the prefix governs where to install the libraries
            install["prefix"] = VIRTUALENV_PATCH_FILE, os.path.abspath(sys.prefix)
        for base in ("purelib", "platlib", "headers", "scripts", "data"):
            key = f"install_{base}"
            if key in install:  # do not allow global configs to hijack venv paths
                install.pop(key, None)
        return result

    dist.Distribution.parse_config_files = parse_config_files


# Import hook that patches some modules to ignore configuration values that break package installation in case
# of virtual environments.
_DISTUTILS_PATCH = "distutils.dist", "setuptools.dist"
# https://docs.python.org/3/library/importlib.html#setting-up-an-importer


class _Finder:
    """A meta path finder that allows patching the imported distutils modules."""

    fullname = None

    # lock[0] is threading.Lock(), but initialized lazily to avoid importing threading very early at startup,
    # because there are gevent-based applications that need to be first to import threading by themselves.
    # See https://github.com/pypa/virtualenv/issues/1895 for details.
    lock = []  # noqa: RUF012

    def find_spec(self, fullname, path, target=None):  # noqa: ARG002
        if fullname in _DISTUTILS_PATCH and self.fullname is None:
            # initialize lock[0] lazily
            if len(self.lock) == 0:
                import threading

                lock = threading.Lock()
                # there is possibility that two threads T1 and T2 are simultaneously running into find_spec,
                # observing .lock as empty, and further going into hereby initialization. However due to the GIL,
                # list.append() operation is atomic and this way only one of the threads will "win" to put the lock
                # - that every thread will use - into .lock[0].
                # https://docs.python.org/3/faq/library.html#what-kinds-of-global-value-mutation-are-thread-safe
                self.lock.append(lock)

            from functools import partial
            from importlib.util import find_spec

            with self.lock[0]:
                self.fullname = fullname
                try:
                    spec = find_spec(fullname, path)
                    if spec is not None:
                        # https://www.python.org/dev/peps/pep-0451/#how-loading-will-work
                        is_new_api = hasattr(spec.loader, "exec_module")
                        func_name = "exec_module" if is_new_api else "load_module"
                        old = getattr(spec.loader, func_name)
                        func = self.exec_module if is_new_api else self.load_module
                        if old is not func:
                            try:  # noqa: SIM105
                                setattr(spec.loader, func_name, partial(func, old))
                            except AttributeError:
                                pass  # C-Extension loaders are r/o such as zipimporter with <3.7
                        return spec
                finally:
                    self.fullname = None
        return None

    @staticmethod
    def exec_module(old, module):
        old(module)
        if module.__name__ in _DISTUTILS_PATCH:
            patch_dist(module)

    @staticmethod
    def load_module(old, name):
        module = old(name)
        if module.__name__ in _DISTUTILS_PATCH:
            patch_dist(module)
        return module


sys.meta_path.insert(0, _Finder())

```

**.venv\Lib\site-packages\gitignore_parser-0.1.11.dist-info\INSTALLER**
```
uv
```

**.venv\Lib\site-packages\gitignore_parser-0.1.11.dist-info\LICENSE**
```
MIT License

Copyright (c) 2018 Michael Herrmann
Copyright (c) 2015 Steve Cook

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

**.venv\Lib\site-packages\gitignore_parser-0.1.11.dist-info\METADATA**
```
Metadata-Version: 2.2
Name: gitignore_parser
Version: 0.1.11
Summary: A spec-compliant gitignore parser for Python 3.5+
Home-page: https://github.com/mherrmann/gitignore_parser
Author: Michael Herrmann
Author-email: michael+removethisifyouarehuman@herrmann.io
License: MIT
Keywords: gitignore
Platform: MacOS
Platform: Windows
Platform: Debian
Platform: Fedora
Platform: CentOS
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: Software Development :: Libraries :: Python Modules
License-File: LICENSE
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: description
Dynamic: home-page
Dynamic: keywords
Dynamic: license
Dynamic: platform
Dynamic: summary

A spec-compliant gitignore parser for Python 3.5+

https://github.com/mherrmann/gitignore_parser

```

**.venv\Lib\site-packages\gitignore_parser-0.1.11.dist-info\RECORD**
```
gitignore_parser-0.1.11.dist-info/LICENSE,sha256=-5gX75pMqgacC0RcAHEG3rC56vFuARy7jQJjTiJ4QaY,1125
gitignore_parser-0.1.11.dist-info/METADATA,sha256=bbE5jOhr2uqXaka4CwZ9WvyEVxYyTer76yt1j5p2WBk,1517
gitignore_parser-0.1.11.dist-info/RECORD,,
gitignore_parser-0.1.11.dist-info/WHEEL,sha256=In9FTNxeP60KnTkGw7wk6mJPYd_dQSjEZmXdBdMCI-8,91
gitignore_parser-0.1.11.dist-info/top_level.txt,sha256=5kVk1Eg7uAXtiBf7Ch_yRgeHvEslsyCBEAJlyBLcWdw,17
gitignore_parser-0.1.11.dist-info\INSTALLER,sha256=5hhM4Q4mYTT9z6QB6PGpUAW81PGNFrYrdXMj4oM_6ak,2
gitignore_parser-0.1.11.dist-info\REQUESTED,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
gitignore_parser.py,sha256=RgfCoWYgh68_caSZ05P5CvO5Z4v1lnZ-ZDmQe_XnyFI,7472

```

**.venv\Lib\site-packages\gitignore_parser-0.1.11.dist-info\REQUESTED**
```

```

**.venv\Lib\site-packages\gitignore_parser-0.1.11.dist-info\top_level.txt**
```txt
gitignore_parser

```

**.venv\Lib\site-packages\gitignore_parser-0.1.11.dist-info\WHEEL**
```
Wheel-Version: 1.0
Generator: setuptools (75.8.0)
Root-Is-Purelib: true
Tag: py3-none-any


```

**.venv\Lib\site-packages\path2md-0.4.0.dist-info\direct_url.json**
```json
{"url":"file:///E:/Users/bitnom/Code/path2md","dir_info":{"editable":true}}
```

**.venv\Lib\site-packages\path2md-0.4.0.dist-info\entry_points.txt**
```txt
[console_scripts]
path2md=path2md.cli:main


```

**.venv\Lib\site-packages\path2md-0.4.0.dist-info\INSTALLER**
```
uv
```

**.venv\Lib\site-packages\path2md-0.4.0.dist-info\METADATA**
```
Metadata-Version: 2.3
Name: path2md
Version: 0.4.0
Summary: Input file or dir path, output markdown file(s).
License: Apache-2.0
Author: bitnom
Author-email: 14287229+bitnom@users.noreply.github.com
Requires-Python: >=3.11,<=3.12
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Requires-Dist: gitignore-parser (>=0.1.11)
Description-Content-Type: text/markdown

# path2md

**Version**: 0.3.3  
**Author**: [bitnom](https://github.com/bitnom)  
**License**: Apache License 2.0  

## Table of Contents

- [Overview](#overview)
- [Installation](#installation)
  - [Install via Poetry (Recommended)](#install-via-poetry-recommended)
  - [Install via pip](#install-via-pip)
- [Usage](#usage)
  - [Basic Example](#basic-example)
  - [Specifying File Extensions](#specifying-file-extensions)
  - [Omitting Files or Directories](#omitting-files-or-directories)
  - [Truncating Lines or Strings](#truncating-lines-or-strings)
  - [Removing Comments](#removing-comments)
  - [Limiting Recursion Depth](#limiting-recursion-depth)
  - [Whitelisting Files or Directories](#whitelisting-files-or-directories)
  - [Using Gitignore](#using-gitignore)
  - [Output Options](#output-options)
- [How It Works](#how-it-works)
- [Known Limitations and Caveats](#known-limitations-and-caveats)
- [Contributing](#contributing)
- [License](#license)

---

## Overview

`path2md` is a command-line tool designed to collect files from a given directory (and its subdirectories) and wrap each file’s content in Markdown code fences. This lets you quickly generate documentation or share your code snippets in a Markdown-friendly format. You can:

- Restrict which files to include (by file extension, whitelists, or `.gitignore`).  
- Omit files by extension or filename but still note their presence in the output.  
- Optionally strip comments to reduce clutter.  
- Truncate lines and/or strings to limit overly long content.  
- Limit consecutive empty lines to make the output more compact.  
- Produce either a single Markdown file or multiple Markdown files (one per source file).  

This tool is especially helpful if you want to share or document multiple files (e.g., sample code, config files) without manually copying and pasting them into code blocks.

---

## Installation

### Install via Poetry (Recommended)

1. **Clone** or **download** this repository.
2. In the project directory (where your `pyproject.toml` is located), run:

   ```bash
   poetry install
   ```

3. Poetry will install all dependencies and create a virtual environment. Once installed, you can either:
   - Use it directly via:
     ```bash
     poetry run path2md --help
     ```
   - Or activate the virtual environment (`poetry shell`) and then run:
     ```bash
     path2md --help
     ```

### Install via pip

1. **Clone** or **download** this repository.
2. From the top-level directory (with the `pyproject.toml`), run:
   ```bash
   pip install .
   ```
   This will build and install the package into your current Python environment.
3. Once installed, you can run:
   ```bash
   path2md --help
   ```

> **Note:** If you want to install in “editable”/dev mode, use:
> ```bash
> pip install -e .
> ```
> Then any local changes to the code reflect immediately.

---

## Usage

After installation (Poetry or pip), you’ll have a `path2md` CLI command in your PATH. Run:

```bash
path2md <directory> [options]
```

Below is a summary of all the available options:

```txt
positional arguments:
  directory             Directory containing files to process.

optional arguments:
  --output-file OUTPUT_FILE     Output markdown file path.
  --output-dir OUTPUT_DIR       Output directory for individual markdown files.
  --extensions EXTENSIONS       Comma-separated list of file extensions to process.
                                Default: py,ts,js,mjs,toml,json,tsx,css,html
  --omit OMIT                   Comma-separated list of file extensions to omit
                                (source omitted but file is noted).
  --omit-files OMIT_FILES       Comma-separated list of filenames to omit (source
                                omitted but file is noted).
  --omit-dirs OMIT_DIRS         Comma-separated list of directory names to omit
                                from traversal entirely.
  --truncln TRUNCLN             Truncate lines longer than this many characters.
  --truncstr TRUNCSTR           Truncate strings longer than this many characters.
  --nocom                       Omit all line/block comments from the output.
  --maxlnspace MAXLNSPACE       Maximum number of consecutive empty lines allowed.
  --depth DEPTH                 Limit directory recursion depth.
  --whitelist-files WHITELIST_FILES
                                Comma-separated list of files to parse.
  --whitelist-dirs WHITELIST_DIRS
                                Comma-separated list of directory names to traverse.
  --whitelist WHITELIST         Comma-separated list of files/dirs to process.
  --gitignore GITIGNORE         Path to a .gitignore file (global).
  --obey-gitignores             Obey .gitignore files found in traversed directories.
  --version                     Show program's version number and exit.
```

### Basic Example

```bash
path2md my_project --output-file project_snippets.md
```

- Traverses `my_project/` looking for files with default extensions (`py, ts, js, mjs, toml, json, tsx, css, html`).  
- Outputs all discovered files into a single Markdown file named `project_snippets.md`.

### Specifying File Extensions

To include additional extensions or limit to specific ones:

```bash
path2md my_project --extensions py,js,json
```

This processes only `.py`, `.js`, and `.json` files.

### Omitting Files or Directories

You can omit files by extension or by exact filename:

```bash
# Omit .env and .lock files, but still note them in the output
path2md my_project --omit env,lock
```

To **completely skip** a directory, use `--omit-dirs`:

```bash
path2md my_project --omit-dirs node_modules,build
```

Any directory named `node_modules` or `build` will not be entered during traversal.

### Truncating Lines or Strings

- `--truncln` truncates individual lines if they exceed a certain length.
- `--truncstr` truncates string literals (e.g., `"..."`, `'...'`, triple quotes, backticks).

Example:

```bash
path2md my_project --truncln 120 --truncstr 200
```

Lines over 120 characters will be shortened, and string literals over 200 characters will be truncated.

### Removing Comments

Use `--nocom` to strip out comments:

```bash
path2md my_project --nocom
```

Currently, this removes:
- `# ...` lines in Python.
- `// ...` lines and `/* ... */` blocks in JS/TS/CSS/HTML.

It is a naive removal (simple regex-based) and won’t handle advanced edge cases (like `#` in a string).

### Limiting Recursion Depth

If you only want to scan subdirectories up to a certain depth from the initial directory:

```bash
path2md my_project --depth 2
```

- `depth=0` means only the directory itself.  
- `depth=1` means the directory and its immediate subdirectories.  

### Whitelisting Files or Directories

If you only want to process specific files or directories:

```bash
path2md my_project --whitelist-files main.py,settings.py
```

This will only process `main.py` and `settings.py` (within the given directory). Similarly, `--whitelist-dirs` only traverses directories whose names match the whitelist. The more general `--whitelist` applies to both file and directory names.

### Using Gitignore

You can specify a global `.gitignore` to skip certain files:

```bash
path2md my_project --gitignore /path/to/.gitignore
```

Or, if you want the script to obey any `.gitignore` found inside subdirectories:

```bash
path2md my_project --obey-gitignores
```

This means each subdirectory’s `.gitignore` rules are also applied.

### Output Options

1. **Output to a single Markdown file**:

   ```bash
   path2md my_project --output-file output.md
   ```

2. **Output to multiple Markdown files (one per source file)**:

   ```bash
   path2md my_project --output-dir output_folder
   ```

   This creates `output_folder/` if it doesn’t exist, then places individual `.md` files for each source file. The filenames are based on the relative paths of the source files but sanitized for filesystem safety.

3. **Output to STDOUT** (default if neither `--output-file` nor `--output-dir` is specified):

   ```bash
   path2md my_project
   ```

---

## How It Works

1. **Argument Parsing**  
   The script reads all CLI options and determines which files/directories to traverse or skip.

2. **File Collection**  
   - Uses `os.walk()` to scan the specified directory.  
   - Checks optional recursion depth, directory whitelists/omits, and `.gitignore` rules to filter out unwanted paths.  
   - Collects only the files that match the specified file extensions (if any).

3. **Fencing Content**  
   For each file that passes the filters:
   - If its extension or filename is in the “omit” lists, it’s only *referenced* (with a note that content is omitted).  
   - Otherwise, the script reads the file content, optionally removes comments, truncates lines/strings, and limits consecutive empty lines.  
   - Wraps the processed text in Markdown fences.

4. **Output**  
   - All fenced content is joined into a single string or separated into multiple Markdown files as requested.  
   - If splitting into multiple files, the script uses a simple split logic on the combined string and writes each chunk to an individual `.md` file.

---

## Known Limitations and Caveats

1. **Naive Regex for Comments and Strings**  
   - The regex approach may remove content that merely *resembles* a comment (e.g., `//` in a string).  
   - Similarly, string truncation might behave unexpectedly with nested quotes or escaped characters.  

2. **Splitting Output in `--output-dir` Mode**  
   - The script splits combined content on `\n**`, which might conflict if your files legitimately contain that exact sequence in code. This is unlikely but worth noting.  

3. **Overwriting Files**  
   - If two different source files sanitize to the same name, the second will overwrite the first in the output directory. (For example, `foo/bar.py` and `foo:bar.py` both becoming `foo_bar_py.md`.)  

4. **Case Sensitivity**  
   - On some filesystems (e.g., Windows), filename case might cause collisions in `--output-dir` mode.  

If these caveats don’t affect your typical use, the script should work fine.

---

## Contributing

Contributions, bug reports, and feature requests are welcome. Please open an issue or submit a pull request on the [GitHub repository](https://github.com/bitnom/path2md) (or wherever the project is hosted).

When submitting code changes, please ensure you:

1. Write clear commit messages.  
2. Include testing or sample usage if you introduce new features.  
3. Adhere to Pythonic style (PEP 8).

---

## License

This project is under the [Apache License 2.0](https://www.apache.org/licenses/LICENSE-2.0). Feel free to modify or distribute under the terms of that license, or use a different license if you prefer.


```

**.venv\Lib\site-packages\path2md-0.4.0.dist-info\RECORD**
```
..\..\Scripts\path2md.exe,sha256=NjLB1TDxil6tH04n5p-QbWeRP0bgt2x1Pj4fyWjI_sA,41388
path2md-0.4.0.dist-info/METADATA,sha256=Xl0ZMZZPa2dFk-Bx_vehMaVwipIGH1rneOwpCUo6SK0,11324
path2md-0.4.0.dist-info/RECORD,,
path2md-0.4.0.dist-info/WHEEL,sha256=RaoafKOydTQ7I_I3JTrPCg6kUmTgtm4BornzOqyEfJ8,88
path2md-0.4.0.dist-info/entry_points.txt,sha256=JcAMy1iPm9IV7QbNRsmvkezTUAQK8tu9TFObwK5Ookw,44
path2md-0.4.0.dist-info\INSTALLER,sha256=5hhM4Q4mYTT9z6QB6PGpUAW81PGNFrYrdXMj4oM_6ak,2
path2md-0.4.0.dist-info\REQUESTED,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
path2md-0.4.0.dist-info\direct_url.json,sha256=I_BG1Kq1eIX9850ZVcKFRYCQA6LLwhdrkU78ue7MCGk,75
path2md-0.4.0.dist-info\uv_cache.json,sha256=rBibZD-5R3-r0m-l-C2WClhvM8W4MHSs-d0jsQD6qj0,100
path2md.pth,sha256=nNtozJI5jIrRCDDxaFL3M_WK7IYCncoYIMVaLGi-YVE,30

```

**.venv\Lib\site-packages\path2md-0.4.0.dist-info\REQUESTED**
```

```

**.venv\Lib\site-packages\path2md-0.4.0.dist-info\uv_cache.json**
```json
{"timestamp":{"secs_since_epoch":1736465472,"nanos_since_epoch":66926300},"commit":null,"tags":null}
```

**.venv\Lib\site-packages\path2md-0.4.0.dist-info\WHEEL**
```
Wheel-Version: 1.0
Generator: poetry-core 2.0.0
Root-Is-Purelib: true
Tag: py3-none-any

```

**.venv\Scripts\activate**
```
# Copyright (c) 2020-202x The virtualenv developers
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file must be used with "source bin/activate" *from bash*
# you cannot run it directly

# Get script path (only used if environment is relocatable).
if [ -n "${BASH_VERSION:+x}" ] ; then
    SCRIPT_PATH="${BASH_SOURCE[0]}"
    if [ "$SCRIPT_PATH" = "$0" ]; then
        # Only bash has a reasonably robust check for source'dness.
        echo "You must source this script: \$ source $0" >&2
        exit 33
    fi
elif [ -n "${ZSH_VERSION:+x}" ] ; then
    SCRIPT_PATH="${(%):-%x}"
elif [ -n "${KSH_VERSION:+x}" ] ; then
    SCRIPT_PATH="${.sh.file}"
fi

deactivate () {
    unset -f pydoc >/dev/null 2>&1 || true

    # reset old environment variables
    # ! [ -z ${VAR+_} ] returns true if VAR is declared at all
    if ! [ -z "${_OLD_VIRTUAL_PATH:+_}" ] ; then
        PATH="$_OLD_VIRTUAL_PATH"
        export PATH
        unset _OLD_VIRTUAL_PATH
    fi
    if ! [ -z "${_OLD_VIRTUAL_PYTHONHOME+_}" ] ; then
        PYTHONHOME="$_OLD_VIRTUAL_PYTHONHOME"
        export PYTHONHOME
        unset _OLD_VIRTUAL_PYTHONHOME
    fi

    # The hash command must be called to get it to forget past
    # commands. Without forgetting past commands the $PATH changes
    # we made may not be respected
    hash -r 2>/dev/null

    if ! [ -z "${_OLD_VIRTUAL_PS1+_}" ] ; then
        PS1="$_OLD_VIRTUAL_PS1"
        export PS1
        unset _OLD_VIRTUAL_PS1
    fi

    unset VIRTUAL_ENV
    unset VIRTUAL_ENV_PROMPT
    if [ ! "${1-}" = "nondestructive" ] ; then
    # Self destruct!
        unset -f deactivate
    fi
}

# unset irrelevant variables
deactivate nondestructive

VIRTUAL_ENV='E:\Users\bitnom\Code\path2md\.venv'
if ([ "$OSTYPE" = "cygwin" ] || [ "$OSTYPE" = "msys" ]) && $(command -v cygpath &> /dev/null) ; then
    VIRTUAL_ENV=$(cygpath -u "$VIRTUAL_ENV")
fi
export VIRTUAL_ENV

_OLD_VIRTUAL_PATH="$PATH"
PATH="$VIRTUAL_ENV/Scripts:$PATH"
export PATH

if [ "xpath2md" != x ] ; then
    VIRTUAL_ENV_PROMPT="(path2md) "
else
    VIRTUAL_ENV_PROMPT="($(basename "$VIRTUAL_ENV")) "
fi
export VIRTUAL_ENV_PROMPT

# unset PYTHONHOME if set
if ! [ -z "${PYTHONHOME+_}" ] ; then
    _OLD_VIRTUAL_PYTHONHOME="$PYTHONHOME"
    unset PYTHONHOME
fi

if [ -z "${VIRTUAL_ENV_DISABLE_PROMPT-}" ] ; then
    _OLD_VIRTUAL_PS1="${PS1-}"
    PS1="${VIRTUAL_ENV_PROMPT}${PS1-}"
    export PS1
fi

# Make sure to unalias pydoc if it's already there
alias pydoc 2>/dev/null >/dev/null && unalias pydoc || true

pydoc () {
    python -m pydoc "$@"
}

# The hash command must be called to get it to forget past
# commands. Without forgetting past commands the $PATH changes
# we made may not be respected
hash -r 2>/dev/null

```

**.venv\Scripts\activate.bat**
```bat
@REM Copyright (c) 2020-202x The virtualenv developers
@REM
@REM Permission is hereby granted, free of charge, to any person obtaining
@REM a copy of this software and associated documentation files (the
@REM "Software"), to deal in the Software without restriction, including
@REM without limitation the rights to use, copy, modify, merge, publish,
@REM distribute, sublicense, and/or sell copies of the Software, and to
@REM permit persons to whom the Software is furnished to do so, subject to
@REM the following conditions:
@REM
@REM The above copyright notice and this permission notice shall be
@REM included in all copies or substantial portions of the Software.
@REM
@REM THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
@REM EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
@REM MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@REM NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
@REM LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
@REM OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
@REM WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

@for %%i in ("E:\Users\bitnom\Code\path2md\.venv") do @set "VIRTUAL_ENV=%%~fi"

@set "VIRTUAL_ENV_PROMPT=path2md"
@if NOT DEFINED VIRTUAL_ENV_PROMPT (
    @for %%d in ("%VIRTUAL_ENV%") do @set "VIRTUAL_ENV_PROMPT=%%~nxd"
)

@if defined _OLD_VIRTUAL_PROMPT (
    @set "PROMPT=%_OLD_VIRTUAL_PROMPT%"
) else (
    @if not defined PROMPT (
        @set "PROMPT=$P$G"
    )
    @if not defined VIRTUAL_ENV_DISABLE_PROMPT (
        @set "_OLD_VIRTUAL_PROMPT=%PROMPT%"
    )
)
@if not defined VIRTUAL_ENV_DISABLE_PROMPT (
    @set "PROMPT=(%VIRTUAL_ENV_PROMPT%) %PROMPT%"
)

@REM Don't use () to avoid problems with them in %PATH%
@if defined _OLD_VIRTUAL_PYTHONHOME @goto ENDIFVHOME
    @set "_OLD_VIRTUAL_PYTHONHOME=%PYTHONHOME%"
:ENDIFVHOME

@set PYTHONHOME=

@REM if defined _OLD_VIRTUAL_PATH (
@if not defined _OLD_VIRTUAL_PATH @goto ENDIFVPATH1
    @set "PATH=%_OLD_VIRTUAL_PATH%"
:ENDIFVPATH1
@REM ) else (
@if defined _OLD_VIRTUAL_PATH @goto ENDIFVPATH2
    @set "_OLD_VIRTUAL_PATH=%PATH%"
:ENDIFVPATH2

@set "PATH=%VIRTUAL_ENV%\Scripts;%PATH%"

```

**.venv\Scripts\activate.csh**
```csh
# Copyright (c) 2020-202x The virtualenv developers
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file must be used with "source bin/activate.csh" *from csh*.
# You cannot run it directly.
# Created by Davide Di Blasi <davidedb@gmail.com>.

set newline='\
'

alias deactivate 'test $?_OLD_VIRTUAL_PATH != 0 && setenv PATH "$_OLD_VIRTUAL_PATH:q" && unset _OLD_VIRTUAL_PATH; rehash; test $?_OLD_VIRTUAL_PROMPT != 0 && set prompt="$_OLD_VIRTUAL_PROMPT:q" && unset _OLD_VIRTUAL_PROMPT; unsetenv VIRTUAL_ENV; unsetenv VIRTUAL_ENV_PROMPT; test "\!:*" != "nondestructive" && unalias deactivate && unalias pydoc'

# Unset irrelevant variables.
deactivate nondestructive

setenv VIRTUAL_ENV 'E:\Users\bitnom\Code\path2md\.venv'

set _OLD_VIRTUAL_PATH="$PATH:q"
setenv PATH "$VIRTUAL_ENV:q/Scripts:$PATH:q"



if ('path2md' != "") then
    setenv VIRTUAL_ENV_PROMPT 'path2md'
else
    setenv VIRTUAL_ENV_PROMPT "$VIRTUAL_ENV:t:q"
endif

if ( $?VIRTUAL_ENV_DISABLE_PROMPT ) then
    if ( $VIRTUAL_ENV_DISABLE_PROMPT == "" ) then
        set do_prompt = "1"
    else
        set do_prompt = "0"
    endif
else
    set do_prompt = "1"
endif

if ( $do_prompt == "1" ) then
    # Could be in a non-interactive environment,
    # in which case, $prompt is undefined and we wouldn't
    # care about the prompt anyway.
    if ( $?prompt ) then
        set _OLD_VIRTUAL_PROMPT="$prompt:q"
        if ( "$prompt:q" =~ *"$newline:q"* ) then
            :
        else
            set prompt = '('"$VIRTUAL_ENV_PROMPT:q"') '"$prompt:q"
        endif
    endif
endif

unset env_name
unset do_prompt

alias pydoc python -m pydoc

rehash

```

**.venv\Scripts\activate.fish**
```fish
# Copyright (c) 2020-202x The virtualenv developers
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file must be used using `source bin/activate.fish` *within a running fish ( http://fishshell.com ) session*.
# Do not run it directly.

function _bashify_path -d "Converts a fish path to something bash can recognize"
    set fishy_path $argv
    set bashy_path $fishy_path[1]
    for path_part in $fishy_path[2..-1]
        set bashy_path "$bashy_path:$path_part"
    end
    echo $bashy_path
end

function _fishify_path -d "Converts a bash path to something fish can recognize"
    echo $argv | tr ':' '\n'
end

function deactivate -d 'Exit virtualenv mode and return to the normal environment.'
    # reset old environment variables
    if test -n "$_OLD_VIRTUAL_PATH"
        # https://github.com/fish-shell/fish-shell/issues/436 altered PATH handling
        if test (echo $FISH_VERSION | head -c 1) -lt 3
            set -gx PATH (_fishify_path "$_OLD_VIRTUAL_PATH")
        else
            set -gx PATH $_OLD_VIRTUAL_PATH
        end
        set -e _OLD_VIRTUAL_PATH
    end

    if test -n "$_OLD_VIRTUAL_PYTHONHOME"
        set -gx PYTHONHOME "$_OLD_VIRTUAL_PYTHONHOME"
        set -e _OLD_VIRTUAL_PYTHONHOME
    end

    if test -n "$_OLD_FISH_PROMPT_OVERRIDE"
       and functions -q _old_fish_prompt
        # Set an empty local `$fish_function_path` to allow the removal of `fish_prompt` using `functions -e`.
        set -l fish_function_path

        # Erase virtualenv's `fish_prompt` and restore the original.
        functions -e fish_prompt
        functions -c _old_fish_prompt fish_prompt
        functions -e _old_fish_prompt
        set -e _OLD_FISH_PROMPT_OVERRIDE
    end

    set -e VIRTUAL_ENV
    set -e VIRTUAL_ENV_PROMPT

    if test "$argv[1]" != 'nondestructive'
        # Self-destruct!
        functions -e pydoc
        functions -e deactivate
        functions -e _bashify_path
        functions -e _fishify_path
    end
end

# Unset irrelevant variables.
deactivate nondestructive

set -gx VIRTUAL_ENV 'E:\Users\bitnom\Code\path2md\.venv'

# https://github.com/fish-shell/fish-shell/issues/436 altered PATH handling
if test (echo $FISH_VERSION | head -c 1) -lt 3
    set -gx _OLD_VIRTUAL_PATH (_bashify_path $PATH)
else
    set -gx _OLD_VIRTUAL_PATH $PATH
end
set -gx PATH "$VIRTUAL_ENV"'/Scripts' $PATH

# Prompt override provided?
# If not, just use the environment name.
if test -n 'path2md'
    set -gx VIRTUAL_ENV_PROMPT 'path2md'
else
    set -gx VIRTUAL_ENV_PROMPT (basename "$VIRTUAL_ENV")
end

# Unset `$PYTHONHOME` if set.
if set -q PYTHONHOME
    set -gx _OLD_VIRTUAL_PYTHONHOME $PYTHONHOME
    set -e PYTHONHOME
end

function pydoc
    python -m pydoc $argv
end

if test -z "$VIRTUAL_ENV_DISABLE_PROMPT"
    # Copy the current `fish_prompt` function as `_old_fish_prompt`.
    functions -c fish_prompt _old_fish_prompt

    function fish_prompt
        # Run the user's prompt first; it might depend on (pipe)status.
        set -l prompt (_old_fish_prompt)

        printf '(%s) ' $VIRTUAL_ENV_PROMPT

        string join -- \n $prompt # handle multi-line prompts
    end

    set -gx _OLD_FISH_PROMPT_OVERRIDE "$VIRTUAL_ENV"
end

```

**.venv\Scripts\activate.nu**
```nu
# Copyright (c) 2020-202x The virtualenv developers
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# virtualenv activation module
# Activate with `overlay use activate.nu`
# Deactivate with `deactivate`, as usual
#
# To customize the overlay name, you can call `overlay use activate.nu as foo`,
# but then simply `deactivate` won't work because it is just an alias to hide
# the "activate" overlay. You'd need to call `overlay hide foo` manually.

export-env {
    def is-string [x] {
        ($x | describe) == 'string'
    }

    def has-env [...names] {
        $names | each {|n|
            $n in $env
        } | all {|i| $i == true}
    }

    # Emulates a `test -z`, but better as it handles e.g 'false'
    def is-env-true [name: string] {
      if (has-env $name) {
        # Try to parse 'true', '0', '1', and fail if not convertible
        let parsed = (do -i { $env | get $name | into bool })
        if ($parsed | describe) == 'bool' {
          $parsed
        } else {
          not ($env | get -i $name | is-empty)
        }
      } else {
        false
      }
    }

    let virtual_env = 'E:\Users\bitnom\Code\path2md\.venv'
    let bin = 'Scripts'

    let is_windows = ($nu.os-info.family) == 'windows'
    let path_name = (if (has-env 'Path') {
            'Path'
        } else {
            'PATH'
        }
    )

    let venv_path = ([$virtual_env $bin] | path join)
    let new_path = ($env | get $path_name | prepend $venv_path)

    # If there is no default prompt, then use the env name instead
    let virtual_env_prompt = (if ('path2md' | is-empty) {
        ($virtual_env | path basename)
    } else {
        'path2md'
    })

    let new_env = {
        $path_name         : $new_path
        VIRTUAL_ENV        : $virtual_env
        VIRTUAL_ENV_PROMPT : $virtual_env_prompt
    }

    let new_env = (if (is-env-true 'VIRTUAL_ENV_DISABLE_PROMPT') {
      $new_env
    } else {
      # Creating the new prompt for the session
      let virtual_prefix = $'(char lparen)($virtual_env_prompt)(char rparen) '

      # Back up the old prompt builder
      let old_prompt_command = (if (has-env 'PROMPT_COMMAND') {
              $env.PROMPT_COMMAND
          } else {
              ''
        })

      let new_prompt = (if (has-env 'PROMPT_COMMAND') {
          if 'closure' in ($old_prompt_command | describe) {
              {|| $'($virtual_prefix)(do $old_prompt_command)' }
          } else {
              {|| $'($virtual_prefix)($old_prompt_command)' }
          }
      } else {
          {|| $'($virtual_prefix)' }
      })

      $new_env | merge {
        PROMPT_COMMAND      : $new_prompt
        VIRTUAL_PREFIX      : $virtual_prefix
      }
    })

    # Environment variables that will be loaded as the virtual env
    load-env $new_env
}

export alias pydoc = python -m pydoc
export alias deactivate = overlay hide activate

```

**.venv\Scripts\activate.ps1**
```ps1
# Copyright (c) 2020-202x The virtualenv developers
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

$script:THIS_PATH = $myinvocation.mycommand.path
$script:BASE_DIR = Split-Path (Resolve-Path "$THIS_PATH/..") -Parent

function global:deactivate([switch] $NonDestructive) {
    if (Test-Path variable:_OLD_VIRTUAL_PATH) {
        $env:PATH = $variable:_OLD_VIRTUAL_PATH
        Remove-Variable "_OLD_VIRTUAL_PATH" -Scope global
    }

    if (Test-Path function:_old_virtual_prompt) {
        $function:prompt = $function:_old_virtual_prompt
        Remove-Item function:\_old_virtual_prompt
    }

    if ($env:VIRTUAL_ENV) {
        Remove-Item env:VIRTUAL_ENV -ErrorAction SilentlyContinue
    }

    if ($env:VIRTUAL_ENV_PROMPT) {
        Remove-Item env:VIRTUAL_ENV_PROMPT -ErrorAction SilentlyContinue
    }

    if (!$NonDestructive) {
        # Self destruct!
        Remove-Item function:deactivate
        Remove-Item function:pydoc
    }
}

function global:pydoc {
    python -m pydoc $args
}

# unset irrelevant variables
deactivate -nondestructive

$VIRTUAL_ENV = $BASE_DIR
$env:VIRTUAL_ENV = $VIRTUAL_ENV

if ("path2md" -ne "") {
    $env:VIRTUAL_ENV_PROMPT = "path2md"
}
else {
    $env:VIRTUAL_ENV_PROMPT = $( Split-Path $env:VIRTUAL_ENV -Leaf )
}

New-Variable -Scope global -Name _OLD_VIRTUAL_PATH -Value $env:PATH

$env:PATH = "$env:VIRTUAL_ENV/Scripts;" + $env:PATH
if (!$env:VIRTUAL_ENV_DISABLE_PROMPT) {
    function global:_old_virtual_prompt {
        ""
    }
    $function:_old_virtual_prompt = $function:prompt

    function global:prompt {
        # Add the custom prefix to the existing prompt
        $previous_prompt_value = & $function:_old_virtual_prompt
        ("(" + $env:VIRTUAL_ENV_PROMPT + ") " + $previous_prompt_value)
    }
}

```

**.venv\Scripts\activate_this.py**
```py
# Copyright (c) 2020-202x The virtualenv developers
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

"""
Activate virtualenv for current interpreter:

import runpy
runpy.run_path(this_file)

This can be used when you must use an existing Python interpreter, not the virtualenv bin/python.
"""  # noqa: D415

from __future__ import annotations

import os
import site
import sys

try:
    abs_file = os.path.abspath(__file__)
except NameError as exc:
    msg = "You must use import runpy; runpy.run_path(this_file)"
    raise AssertionError(msg) from exc

bin_dir = os.path.dirname(abs_file)
base = bin_dir[: -len("Scripts") - 1]  # strip away the bin part from the __file__, plus the path separator

# prepend bin to PATH (this file is inside the bin directory)
os.environ["PATH"] = os.pathsep.join([bin_dir, *os.environ.get("PATH", "").split(os.pathsep)])
os.environ["VIRTUAL_ENV"] = base  # virtual env is right above bin directory
os.environ["VIRTUAL_ENV_PROMPT"] = "path2md" or os.path.basename(base)  # noqa: SIM222

# add the virtual environments libraries to the host python import mechanism
prev_length = len(sys.path)
for lib in "..\\Lib\\site-packages".split(os.pathsep):
    path = os.path.realpath(os.path.join(bin_dir, lib))
    site.addsitedir(path)
sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]

sys.real_prefix = sys.prefix
sys.prefix = base

```

**.venv\Scripts\deactivate.bat**
```bat
@REM Copyright (c) 2020-202x The virtualenv developers
@REM
@REM Permission is hereby granted, free of charge, to any person obtaining
@REM a copy of this software and associated documentation files (the
@REM "Software"), to deal in the Software without restriction, including
@REM without limitation the rights to use, copy, modify, merge, publish,
@REM distribute, sublicense, and/or sell copies of the Software, and to
@REM permit persons to whom the Software is furnished to do so, subject to
@REM the following conditions:
@REM
@REM The above copyright notice and this permission notice shall be
@REM included in all copies or substantial portions of the Software.
@REM
@REM THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
@REM EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
@REM MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@REM NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
@REM LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
@REM OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
@REM WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

@set VIRTUAL_ENV=
@set VIRTUAL_ENV_PROMPT=

@REM Don't use () to avoid problems with them in %PATH%
@if not defined _OLD_VIRTUAL_PROMPT @goto ENDIFVPROMPT
    @set "PROMPT=%_OLD_VIRTUAL_PROMPT%"
    @set _OLD_VIRTUAL_PROMPT=
:ENDIFVPROMPT

@if not defined _OLD_VIRTUAL_PYTHONHOME @goto ENDIFVHOME
    @set "PYTHONHOME=%_OLD_VIRTUAL_PYTHONHOME%"
    @set _OLD_VIRTUAL_PYTHONHOME=
:ENDIFVHOME

@if not defined _OLD_VIRTUAL_PATH @goto ENDIFVPATH
    @set "PATH=%_OLD_VIRTUAL_PATH%"
    @set _OLD_VIRTUAL_PATH=
:ENDIFVPATH
```

**.venv\Scripts\pydoc.bat**
```bat
@REM Copyright (c) 2020-202x The virtualenv developers
@REM
@REM Permission is hereby granted, free of charge, to any person obtaining
@REM a copy of this software and associated documentation files (the
@REM "Software"), to deal in the Software without restriction, including
@REM without limitation the rights to use, copy, modify, merge, publish,
@REM distribute, sublicense, and/or sell copies of the Software, and to
@REM permit persons to whom the Software is furnished to do so, subject to
@REM the following conditions:
@REM
@REM The above copyright notice and this permission notice shall be
@REM included in all copies or substantial portions of the Software.
@REM
@REM THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
@REM EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
@REM MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@REM NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
@REM LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
@REM OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
@REM WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

python.exe -m pydoc %*
```

**path2md\cli.py**
```py
#!/home/zensin/.pyenv/shims/python3

import argparse
import os
import re
from gitignore_parser import parse_gitignore
from pathlib import Path

__version__ = "0.4.0"


def parse_arguments():
    parser = argparse.ArgumentParser(description="Wrap file contents in markdown code fences.")
    parser.add_argument("directory", type=str, help="Directory containing files to process.")

    # Mutually exclusive group for output-file vs. output-dir
    output_group = parser.add_mutually_exclusive_group()
    output_group.add_argument(
        "--output-file",
        type=str,
        help="Output markdown file path. If not provided, output will be printed to console."
    )
    output_group.add_argument(
        "--output-dir",
        type=str,
        help="Output directory for individual markdown files."
    )

    # By default, parse all extensions unless --extensions is specified
    parser.add_argument(
        "--extensions",
        type=lambda s: s.split(','),
        default=None,
        help=(
            "Comma-separated list of file extensions to process. "
            "By default, all file extensions are processed unless this is provided."
        ),
    )

    parser.add_argument(
        "--omit",
        type=lambda s: s.split(','),
        default=[],
        help="Comma-separated list of file extensions to omit but still reference in the output."
    )
    parser.add_argument(
        "--omit-files",
        type=lambda s: s.split(','),
        default=[],
        help="Comma-separated list of filenames to omit but still reference in the output."
    )
    parser.add_argument(
        "--omit-dirs",
        type=lambda s: s.split(','),
        default=[],
        help="Comma-separated list of directory names to omit from traversal."
    )
    parser.add_argument(
        "--truncln",
        type=int,
        default=None,
        help="Truncate lines longer than this number of characters. Default: None"
    )
    parser.add_argument(
        "--truncstr",
        type=int,
        default=None,
        help="Truncate strings longer than this number of characters. Default: None"
    )
    parser.add_argument(
        "--nocom",
        action='store_true',
        help="Omit all line and block comments from the output."
    )
    parser.add_argument(
        "--maxlnspace",
        type=int,
        default=None,
        help="Maximum number of consecutive empty lines allowed in the output. Default: None"
    )
    parser.add_argument(
        "--depth",
        type=int,
        default=None,
        help="Limit the directory recursion depth. Default: None"
    )
    parser.add_argument(
        "--whitelist-files",
        type=lambda s: s.split(','),
        default=[],
        help=(
            "Comma-separated list of files to parse. If specified, only these files will be parsed."
        ),
    )
    parser.add_argument(
        "--whitelist-dirs",
        type=lambda s: s.split(','),
        default=[],
        help=(
            "Comma-separated list of directory names to traverse. "
            "If specified, only these directories will be traversed."
        ),
    )
    parser.add_argument(
        "--whitelist",
        type=lambda s: s.split(','),
        default=[],
        help=(
            "Comma-separated list of directory names and/or file names to traverse/parse. "
            "If specified, only these will be processed."
        ),
    )
    parser.add_argument(
        "--gitignore",
        type=str,
        default=None,
        help="Path to .gitignore file. If provided, files and directories matching the gitignore patterns will be skipped."
    )
    parser.add_argument(
        "--obey-gitignores",
        action='store_true',
        help="Obey .gitignore files found in traversed directories."
    )

    # New option: skip files larger than max-size (default: 100 KB)
    parser.add_argument(
        "--max-size",
        type=int,
        default=100 * 1024,  # 100 KB
        help="Maximum file size in bytes to process. Default: 100 KB"
    )

    # Version argument
    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {__version__}"
    )

    return parser.parse_args()


def load_gitignore(directory):
    """
    Load and return a gitignore matcher for the given directory,
    if a .gitignore file is found there.
    """
    gitignore_path = os.path.join(directory, '.gitignore')
    if os.path.exists(gitignore_path):
        return parse_gitignore(gitignore_path)
    return None


def is_binary_file(file_path, block_size=1024):
    """
    Read the first `block_size` bytes of the file in binary mode.
    If it contains a null byte, treat as binary.
    """
    try:
        with open(file_path, 'rb') as f:
            chunk = f.read(block_size)
        return b'\0' in chunk
    except Exception:
        # If we can't read the file, skip it safely
        return True


def list_files(
    directory,
    extensions,
    max_depth=None,
    omit_dirs=None,
    whitelist_files=None,
    whitelist_dirs=None,
    whitelist=None,
    global_gitignore_matcher=None,
    obey_gitignores=False,
    max_size=100*1024
):
    """
    Traverse the directory tree and return a list of file paths that match
    the provided conditions, while obeying whitelists, omit lists, file size,
    binary-file checks, and gitignores.
    """
    if omit_dirs is None:
        omit_dirs = []
    if whitelist_files is None:
        whitelist_files = []
    if whitelist_dirs is None:
        whitelist_dirs = []
    if whitelist is None:
        whitelist = []

    file_list = []
    start_depth = directory.count(os.sep)

    # Start a stack for .gitignore matchers. If a global gitignore was provided, push it.
    gitignore_stack = []
    if global_gitignore_matcher:
        gitignore_stack.append(global_gitignore_matcher)

    for root, dirs, files in os.walk(directory):
        current_depth = root.count(os.sep) - start_depth
        if max_depth is not None and current_depth >= max_depth:
            # Do not walk deeper
            dirs[:] = []
            continue

        # Remember how many matchers are on the stack before checking local .gitignore
        stack_len_before = len(gitignore_stack)

        if obey_gitignores:
            # Load the local .gitignore for the current directory
            local_gitignore = load_gitignore(root)
            if local_gitignore:
                gitignore_stack.append(local_gitignore)

        # The "active" ignore is the top of the stack (if any)
        current_gitignore = gitignore_stack[-1] if gitignore_stack else None

        # Handle whitelisted vs omitted directories
        if whitelist_dirs:
            dirs[:] = [d for d in dirs if d in whitelist_dirs]
        elif whitelist:
            # If a general whitelist is provided (files + dirs), skip directories not in it
            dirs[:] = [d for d in dirs if d in whitelist]
        else:
            # Omit directories explicitly listed
            dirs[:] = [d for d in dirs if d not in omit_dirs]

        # If there's a gitignore, filter out directories it matches
        if current_gitignore:
            dirs[:] = [d for d in dirs if not current_gitignore(os.path.join(root, d))]

        for file in files:
            file_path = os.path.join(root, file)
            relative_path = os.path.relpath(file_path, directory)

            # Check whitelist files
            if whitelist_files and file not in whitelist_files:
                continue
            # Or a general whitelist
            if whitelist and (relative_path not in whitelist and file not in whitelist):
                continue
            # Check gitignore
            if current_gitignore and current_gitignore(file_path):
                continue
            # Skip if file is too large
            if os.path.getsize(file_path) > max_size:
                continue
            # Skip binary files
            if is_binary_file(file_path):
                continue

            # If --extensions was provided, check extension
            if extensions is not None:
                if os.path.splitext(file)[1][1:] in extensions:
                    file_list.append(file_path)
            else:
                # By default (extensions=None), parse everything (non-binary, size OK, not ignored)
                file_list.append(file_path)

        # After processing the current directory, pop any local .gitignore we added
        if obey_gitignores:
            while len(gitignore_stack) > stack_len_before:
                gitignore_stack.pop()

    return file_list


def remove_comments(content, extension):
    """
    REMAIN UNCHANGED (per your request):
    Naive removal of # lines in Python or // and /* */ in JS/TS/CSS/HTML.
    """
    if extension in ['py']:
        content = re.sub(r'#.*', '', content)
    elif extension in ['js', 'ts', 'mjs', 'tsx', 'css', 'html']:
        content = re.sub(r'//.*', '', content)
        content = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
    return content


def truncate_strings(content, truncstr):
    string_patterns = [
        r'\'[^\']*\'',
        r'\"[^\"]*\"',
        r'\'\'\'(.*?)\'\'\'',
        r'\"\"\"(.*?)\"\"\"',
        r'\`[^\`]*\`'
    ]

    def truncate_match(match):
        string = match.group(0)
        if len(string) > truncstr:
            if string.startswith("'''") or string.startswith('"""'):
                return string[:truncstr] + '... (String truncated) ' + string[:3]
            else:
                return string[:truncstr] + '... (String truncated)' + string[-1]
        return string

    for pattern in string_patterns:
        content = re.sub(pattern, truncate_match, content, flags=re.DOTALL)
    return content


def truncate_line(line, truncln):
    if len(line) <= truncln:
        return line
    if line[truncln - 1] in ['\'', '\"', '`']:
        return line[:truncln] + " // (Line truncated to save space)"
    return line[:truncln] + " // (Line truncated to save space)" + line[-1]


def limit_consecutive_empty_lines(content, maxlnspace):
    if maxlnspace is None:
        return content
    lines = content.splitlines()
    new_lines = []
    empty_line_count = 0
    for line in lines:
        if line.strip() == "":
            empty_line_count += 1
        else:
            empty_line_count = 0
        if empty_line_count <= maxlnspace:
            new_lines.append(line)
    return "\n".join(new_lines)


def read_and_fence(file_path, base_directory, omit_extensions, omit_files, truncln, truncstr, nocom, maxlnspace):
    extension = os.path.splitext(file_path)[1][1:]
    relative_path = os.path.relpath(file_path, base_directory)
    filename = os.path.basename(file_path)

    # If extension or file is in omit list, only note it, don’t print code
    if extension in omit_extensions or filename in omit_files:
        return f"**{relative_path}** (Source omitted to save space)\n"

    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            content = file.read()

        if nocom:
            content = remove_comments(content, extension)

        if truncstr:
            content = truncate_strings(content, truncstr)

        if truncln:
            content = '\n'.join(truncate_line(line, truncln) for line in content.splitlines())

        if maxlnspace is not None:
            content = limit_consecutive_empty_lines(content, maxlnspace)

        return f"**{relative_path}**\n```{extension}\n{content}\n```\n"
    except Exception as e:
        return f"**{relative_path}** (Error reading file: {e})\n"


def concatenate_markdown(files, base_directory, omit_extensions, omit_files, truncln, truncstr, nocom, maxlnspace):
    """
    Read and fence all files in the list, then concatenate into a single string.
    """
    return "\n".join(
        read_and_fence(
            file,
            base_directory,
            omit_extensions,
            omit_files,
            truncln,
            truncstr,
            nocom,
            maxlnspace
        )
        for file in files
    )


def sanitize_filename(filename):
    """
    Replaces characters that are invalid on common filesystems.
    """
    return re.sub(r'[<>:"/\\|?*]', '_', str(filename))


def write_to_file(content, output_file, output_dir):
    """
    Write 'content' to a single file if output_file is specified;
    write each file's fenced content separately if output_dir is specified;
    otherwise print to stdout.
    """
    if output_dir:
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)

        # Each file's content starts with "**{relative_path}**"
        # So we split on '\n**' to chunk them.
        chunks = content.split('\n**')
        for chunk in chunks:
            chunk = chunk.strip()
            if not chunk:
                continue
            # Attempt to split the leading file path from the rest
            try:
                file_path, file_body = chunk.split('**\n', 1)
            except ValueError:
                # If there's no '**\n', skip
                continue
            file_path = file_path.strip()
            sanitized_path = sanitize_filename(file_path)
            # Each chunk goes to its own .md
            out_file = output_path / f"{sanitized_path}.md"
            out_file.parent.mkdir(parents=True, exist_ok=True)
            with out_file.open('w', encoding='utf-8') as f:
                f.write(f"**{file_path}**\n{file_body}")

    elif output_file:
        with open(output_file, 'w', encoding='utf-8') as file:
            file.write(content)
    else:
        print(content)


def main():
    args = parse_arguments()

    # Load a global gitignore if specified
    global_gitignore_matcher = None
    if args.gitignore:
        global_gitignore_matcher = parse_gitignore(args.gitignore)

    abs_directory = os.path.abspath(args.directory)

    files = list_files(
        abs_directory,
        args.extensions,
        args.depth,
        args.omit_dirs,
        args.whitelist_files,
        args.whitelist_dirs,
        args.whitelist,
        global_gitignore_matcher,
        args.obey_gitignores,
        max_size=args.max_size
    )

    markdown_content = concatenate_markdown(
        files,
        abs_directory,
        args.omit,
        args.omit_files,
        args.truncln,
        args.truncstr,
        args.nocom,
        args.maxlnspace
    )

    write_to_file(markdown_content, args.output_file, args.output_dir)


if __name__ == "__main__":
    main()

```

**path2md\__init__.py**
```py

```
